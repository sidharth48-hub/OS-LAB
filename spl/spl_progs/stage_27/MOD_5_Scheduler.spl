alias currentPID R0;
currentPID = [SYSTEM_STATUS_TABLE + 1];
multipush(BP);

alias process_table_entry R1;
process_table_entry = PROCESS_TABLE + currentPID*16;

[process_table_entry + 12] = SP%512;
[process_table_entry + 14] = PTBR;
[process_table_entry + 15] = PTLR;


alias iter R2;
alias newPID R3;

newPID = -1;
//if paging is taking place
if([SYSTEM_STATUS_TABLE + 5] != 0) then
      
    if([PROCESS_TABLE + 15*16 + 4] == WAIT_DISK) then
        newPID = 0; //idle
    else
        newPID = 15; //swapper daemon
    endif;

endif;

if(newPID == -1) then
    iter = currentPID + 1;
    
    while(iter < SWAPPER_DAEMON) do
        //finding a non-swapped process
        if(([PROCESS_TABLE + iter*16 + 4] == CREATED || [PROCESS_TABLE + iter*16 + 4] == READY) && ([PROCESS_TABLE + iter*16 + 6] == 0)) then
            newPID = iter;
            break;
        endif;
        iter = iter + 1;
    endwhile;

    if(newPID == -1) then

        iter = 1;
        while(iter < currentPID) do
            //finding a non-swapped process
            if(([PROCESS_TABLE + iter*16 + 4] == CREATED || [PROCESS_TABLE + iter*16 + 4] == READY) && ([PROCESS_TABLE + iter*16 + 6] == 0)) then
                newPID = iter;
                break;
            endif;
            iter = iter + 1;
        endwhile;

    endif;

    if(newPID == -1) then
        newPID = IDLE_PROCESS;
    endif;
endif;

alias new_process_table R5;
new_process_table = PROCESS_TABLE + newPID*16;

SP = [new_process_table + 11]*512 + [new_process_table + 12];
PTBR = [new_process_table + 14];
PTLR = [new_process_table + 15];

[SYSTEM_STATUS_TABLE + 1] = newPID;

if([new_process_table + 4]==CREATED) then
   SP = [new_process_table + 13];
   BP = [[new_process_table + 11] * 512];
   [new_process_table + 4] = RUNNING;
   [new_process_table + 9] = 0;
   ireturn;
endif;

[new_process_table + 4] = RUNNING;
multipop(BP);
return;