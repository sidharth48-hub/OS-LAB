[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1]*16) + 11] * 512 - 1;
backup;

if([SYSTEM_STATUS_TABLE + 5] != 0) then
    
    //if swapper daemon is being executed
    if([SYSTEM_STATUS_TABLE + 1] == 15) then
        if([SYSTEM_STATUS_TABLE + 5] == SWAP_OUT) then
            R1 = SWAP_OUT;
            R2 = [SYSTEM_STATUS_TABLE + 1];
            call MOD_6;
        else
            R1 = SWAP_IN;
            R2 = [SYSTEM_STATUS_TABLE + 1];
            call MOD_6;
        endif;
    endif;

else
    // if memory count is low
    // swap out check
    if([SYSTEM_STATUS_TABLE+2]< MEM_LOW) then

        [SYSTEM_STATUS_TABLE+5] = SWAP_OUT;

    else
        R1 = SHELL_PROCESS+1;
        //   swap in check
        while(R1 < SWAPPER_DAEMON) do
            if([PROCESS_TABLE + R1*16 + 6] == 1  && ([PROCESS_TABLE + R1*16] > MAX_TICK || [SYSTEM_STATUS_TABLE + 2] > MEM_HIGH)) then
                [SYSTEM_STATUS_TABLE + 5] = SWAP_IN;
                break;
            endif;

            R1 = R1+1;
        endwhile;
    endif;
    


    

endif;


[PROCESS_TABLE +[SYSTEM_STATUS_TABLE + 1]*16 + 4] = READY;

alias count R1;
count=SHELL_PROCESS+1;

//TICK COUNT
while(count<SWAPPER_DAEMON) do
    if([PROCESS_TABLE + count*16 + 4] != TERMINATED) then
        [PROCESS_TABLE + count*16 ] = [PROCESS_TABLE + count*16] + 1;
    endif;
    
    count=count+1;
endwhile;

call MOD_5;

restore;
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13];
[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE+1]*16) + 9] = 0;
ireturn;